import json
import requests

# These are the rclone rc API routes
RCLONE_RC_URL = "http://localhost:5572"
RCLONE = {
    "mkdir": "operations/mkdir",
    "purge": "operations/purge",
    "deleteFile": "operations/deletefile",
    "createPublicLink": "operations/publiclink",
    "stats": "core/stats",
    "bwlimit": "core/bwlimit",
    "moveDir": "sync/move",
    "moveFile": "operations/movefile",
    "copyDir": "sync/copy",
    "copyFile": "operations/copyfile",
    "cleanUpRemote": "operations/cleanup",
    "noopAuth": "rc/noopauth",
    "getRcloneVersion": "core/version",
    "getRcloneMemStats": "core/memstats",
    "getOptions": "options/get",
    "getProviders": "config/providers",
    "getConfigDump": "config/dump",
    "getRunningJobs": "job/list",
    "getStatusForJob": "job/status",
    "getConfigForRemote": "config/get",
    "createConfig": "config/create",
    "updateConfig": "config/update",
    "getFsInfo": "operations/fsinfo",
    "listRemotes": "config/listremotes",
    "getFilesList": "operations/list",
    "getAbout": "operations/about",
    "deleteConfig": "config/delete",
    "stopJob": "job/stop",
    "backendCommand": "backend/command",
    "coreCommand": "core/command",
    "transferred": "core/transferred",
    "getSize": "operations/size",
    "statsDelete": "core/stats-delete",
    "statsReset": "core/stats-reset",
}

# Movies example
# In this example, the user provides a path to a Movie folder in the config
PATH = "Movies - Development"
# The FS is the rclone config that will be used. This won't involve the user and will be set by the config generator
FS = "ldd:"

# Here, a request is made to rclone's rc API requesting a recursed list of files and folders
data = {"fs": FS, "remote": PATH, "opt": {"recurse": True}}
result = requests.post(
    "%s/%s" % (RCLONE_RC_URL, RCLONE["getFilesList"]),
    data=json.dumps(data),
    headers={"Content-Type": "application/json"},
).json()

metadata = []
dirs = {}
for item in result["list"]:
    # Example item generated by rclone
    # {
    #     "Path": "Movies - Development/Avengers  Endgame (2019) [x264] [1080p]/Avengers: Endgame (2019) [x264] [1080p].mp4",
    #     "Name": "Avengers: Endgame (2019) [x264] [1080p].mp4",
    #     "Size": 28818579,
    #     "MimeType": "video/mp4",
    #     "ModTime": "2021-08-30T14:55:50.750Z",
    #     "IsDir": False,
    #     "ID": "14pqGquR3OB0gpLW8ArvjHOrzHYGxwa0m",
    # }
    if item["IsDir"] == False:
        # To get the ID of a parent, I made a workaround. Ideally, this should be removed because it adds inneficiency.
        # For now, I'll keep it incase it is needed in the future
        parent_path = item["Path"].replace("/" + item["Name"], "")
        parent = dirs[parent_path]
        metadata.append(
            {
                "id": item["ID"],
                "name": item["Name"],
                "parent": parent,
                "modifiedTime": item["ModTime"],
            }
        )
        # Example item generated by this algorithm
        # {
        #     "id": "14pqGquR3OB0gpLW8ArvjHOrzHYGxwa0m",
        #     "name": "Avengers: Endgame (2019) [x264] [1080p].mp4",
        #     "parent": {
        #         "id": "11UV4EvYpbRxZQf7tRXPkW99NGg5yoz-L",
        #         "name": "Avengers  Endgame (2019) [x264] [1080p]"
        #     },
        #     "modifiedTime": "2021-08-30T14:55:50.750Z"
        # }
    else:
        # This is what allows the parent to be identified
        dirs[item["Path"]] = {"id": item["ID"], "name": item["Name"]}

with open("metadata.json", "w+") as w:
    json.dump(metadata, w, indent=4)
